
;************************************************************************
;*                                                                      *
;*                      INTELLEC SERIES II BOOT/MONITOR                 *
;*                              VERSION 1.2                             *
;*                                                                      *
;*      COPYRIGHT (C) 1978 INTEL CORPORATION.  ALL RIGHTS               *
;*      RESERVED.  NO PART OF THIS PROGRAM OR PUBLICATION               *
;*      MAY BE REPRODUCED, TRANSMITTED, TRANSCRIBED,                    *
;*      STORED IN A RETRIEVAL SYSTEM, OR TRANSLATED INTO                *
;*      ANY LANGUAGE OR COMPUTER LANGUAGE, IN ANY FORM                  *
;*      OR BY ANY MEANS, ELECTRONIC, MECHANICAL, MAGNETIC,              *
;*      OPTICAL, CHEMICAL, MANUAL OR OTHERWISE, WITHOUT                 *
;*      THE PRIOR WRITTEN PERMISSION OF INTEL CORPORATION,              *
;*      3065 BOWERS AVENUE, SANTA CLARA, CALIFORNIA 95051.              *
;*                                                                      *
;************************************************************************
; <LEGAL COMMAND> ::=   <ASSIGN I/O COMMAND>
;                       <DISPLAY MEMORY COMMAND>
;                       <ENDFILE COMMAND>
;                       <FILL MEMORY COMMAND>
;                       <PROGRAM EXECUTE COMMAND>
;                       <HEXADECIMAL ARITHMETIC COMMAND>
;                       <MOVE MEMORY COMMAND>
;                       <LEADER COMMAND>
;                       <QUERY STATUS COMMAND>
;                       <READ HEXADECIMAL FILE COMMAND>
;                       <SUBSTITUTE MEMORY COMMAND>
;                       <WRITE HEXADECIMAL RECORD COMMAND>
;                       <REGISTER MODIFY COMMAND>
;                       <TRANSFER CONTROL TO DIAGNOSTIC PROGRAM COMMAND>
; <ASSIGN I/O COMMAND> ::= A<LOGICAL DEVICE>=<PHYSICAL DEVICE>
; <DISPLAY MEMORY COMMAND> ::= D<NUMBER>,<NUMBER>
; <ENDFILE COMMAND> ::= E<NUMBER>
; <FILL MEMORY COMMAND> ::= F<NUMBER>,<NUMBER>,<NUMBER>
; <PROGRAM EXECUTE COMMAND> ::= G<NUMBER>,<NUMBER>,<NUMBER>
; <HEXADECIMAL ARITHMETIC COMMAND> ::= H<NUMBER>,<NUMBER>
; <MOVE MEMORY COMMAND> ::= M<NUMBER>,<NUMBER>,<NUMBER>
; <LEADER COMMAND> ::= N
; <QUERY STATUS COMMAND> ::= Q
; <READ HEXADECIMAL FILE COMMAND> ::= R<NUMBER>
; <SUBSTITUTE MEMORY COMMAND> ::= S<NUMBER><COMMA>...
; <WRITE HEXADECIMAL RECORD COMMAND> ::= W<NUMBER>,<NUMBER>
; <REGISTER MODIFY COMMAND> ::= X<REGISTER IDENTIFIER><NUMBER>...
; <TRANSFER CONTROL TO DIAGNOSTIC PROGRAM COMMAND> ::= Z$
; <LOGICAL DEVICE> ::= LOCAL CONSOLE!READER!LIST!PUNCH
; <PHYSICAL DEVICE> ::= CRT!TTY!PTR!PTP!LPT!BATCH!1!2
; <REGISTER IDENTIFIER> ::= A!B!C!D!E!F!H!I!L!M!P!S
; <NUMBER> ::=  <HEX DIGIT>
;               <NUMBER><HEX DIGIT>
; <HEX DIGIT> ::= 0!1!2!3!4!5!6!7!8!9!A!B!C!D!E!F
;*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
$	TITLE	(' INTELLEC SERIES II MONITOR, VERSION 1.2, 4 JANUARY 1978 ')
VER	EQU	12	; VERSION 1.2
VERH	EQU	12h	; STORAGE REPRESENTATION OF VERSION
DATE	EQU	0401H	; CREATION DATE, 04 JANUARY 1978
; NOTE:
; THE DATE SHOWN ABOVE IS ENCODED IN A TWO BYTE FIELD IN BOTH THE BOOTSTRAP
; PROM AND THE MONITOR PROM IN ORDER TO CONTROL NEW RELEASES OF THIS PROGRAM.
; THE DATE CODE IS LOCATED AT ADDRESSES 0E804H AND 0E805H IN THE BOOTSTRAP
; AND AT ADDRESSES 0F824H AND 0F825H IN THE MONITOR.
; THE VERSION CODE IS LOCATED IN THE MONITOR ROM AT ADDRESS 0F82FH.
; WHEN A NEW RELEASE IS ISSUED, PLEASE CHANGE THE DATE AND VERSION CODES.
; THE COPYRIGHT NOTICE IS LOCATED IN THE MONITOR ROM BEGINNING AT 0F830H.
;********************************************************************************
;*                                                                              *
;*                      SYMBOL DEFINITIONS                                      *
;*                                                                              *
;********************************************************************************
;
; INTELLEC SERIES II SYSTEM CONSTANTS
;
; INTEGRATED CONSOLE I/O PORTS
;
CONI	EQU	0C0H		; CONSOLE INPUT DATA PORT
CONO	EQU	0C0H		; CONSOLE OUTPUT DATA PORT
CONS	EQU	0C1H		; CONSOLE STATUS PORT
CONC	EQU	0C1H		; CONSOLE CONTROL PORT
;
; SYSTEM BOOTSTRAP CONSTANTS (ISSUED TO PORT CPUC)
;
DISABL	EQU	0DH		; DISABLE INTERRUPTS
ENABL	EQU	05H		; ENABLE INTERRUPTS
DISAXP	EQU	00H		; DISABLE AUXILIARY PROM

ENAXP	EQU	08H		; ENABLE AUXILIARY PROM
BOVROF	EQU	01H		; TURN OFF BUS OVERRIDE
BOVRON	EQU	09H		; TURN ON BUS OVERRIDE
BTDGOF	EQU	04H		; TURN OFF BOOT/DIAGNOSTIC
BTDGON	EQU	0CH		; TURN ON BOOT/DIAGNOSTIC
MOVBOT	EQU	02H		; MOVE BOOT TO 0E800H
;
; SYSTEM I/O PORTS
;
CPUS	EQU	0FEH		; CPU STATUS PORT
CPUC	EQU	0FFH		; CPU CONTROL PORT (CONTROLS BOOT & AUX.PROM)
;
; SYSTEM INTERRUPT CONSTANTS
;
ICW1	EQU	00010010B	; INITIALIZATION COMMAND WORD 1
ICW2	EQU	00000000B	; INITIALIZATION COMMAND WORD 2
OCW3	EQU	00001011B	; OPERATION COMMAND WORD 3
EOI	EQU	00100000B	; END OF INTERRUPT
;
; SYSTEM INTERRUPT MASKS AND VALUES
;
INT0	EQU	00000001B	; MASK FOR INTERRUPT LEVEL 0
INT1	EQU	00000010B
INT2	EQU	00000100B
INT3	EQU	00001000B
INT4	EQU	00010000B
INT5	EQU	00100000B
INT6	EQU	01000000B
INT7	EQU	10000000B
INTA	EQU	00000000B	; NO INTERRUPTS ALLOWED AT ALL
;
; SYSTEM INTERRUPT I/O PORTS
;
SICP0	EQU	0FDH		; INITIALIZATION COMMAND PORT 0
SICP1	EQU	0FCH		; INITIALIZATION COMMAND PORT 1
SOCP0	EQU	0FDH		; OPERATION COMMAND PORT 0
SOCP1	EQU	0FCH		; OPERATION COMMAND PORT 1
;
; DEDICATED PROM PROGRAMMER CONSTANTS (USED IN C,P,T COMMANDS)
;
PCOMP	EQU	00000010B	; PROGRAMMING COMPLETE
PGRDY	EQU	00000001B	; PROM READY
PSOCK	EQU	00100000B	; 16 PIN SOCKET SELECTED
PNIB	EQU	00010000B	; SELECT UPPER NIBBLE
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; INTELLEC SERIES II I/O SUBSYSTEM CONSTANTS
;
; TTY AND CRT MODE INSTRUCTION DEFINITIONS, I.E. USART MODE CONTROL
; WORD (FIRST CONTROL BYTE AFTER RESET)
;
R64X	EQU	00000011B	; 64 X BAUD RATE
R16X	EQU	00000010B	; 16 X BAUD RATE
R1X	EQU	00000001B	;  1 X BAUD RATE
SYNC	EQU	00000000B	; SYNC MODE
CL8	EQU	00001100B	; CHARACTER LENGTH = 8
CL7	EQU	00001000B	; CHARACTER LENGTH = 7
CL6	EQU	00000100B	; CHARACTER LENGTH = 6
CL5	EQU	00000000B	; CHARCTER LENGTH = 5
PENB	EQU	00010000B	; PARITY ENABLE
PEVEN	EQU	00100000B	; EVEN PARITY
ST2	EQU	11000000B	; 2 STOP BITS
ST15	EQU	10000000B	; 1.5 STOP BITS
ST1	EQU	01000000B	; 1 STOP BIT
;
; TTY AND CRT COMMAND INSTRUCTION DEFINITIONS (USART COMMAND CONTROL WORD)
;
TXEN	EQU	00000001B	; TRANSMITTER ENABLE
DTR	EQU	00000010B	; DATA TERMINAL READY
RXEN	EQU	00000100B	; ENABLE RECEIVER
SBCH	EQU	00001000B	; SEND BREAK CHARACTER
CLERR	EQU	00010000B	; CLEAR ERROR
RTS	EQU	00100000B	; SET REQUEST TO SEND OUTPUT
USRST	EQU	01000000B	; USART RESET - RETURN TO MODE CONTROL CYCLE
ENHM	EQU	10000000B	; ENABLE HUNT MODE
;
; TTY/CRT STATUS WORD BIT DEFINITIONS
;
TRDY	EQU	00000001B	; TRANSMIT READY
RRDY	EQU	00000010B	; RECEIVE BUFFER READY
TXBE	EQU	00000100B	; TRANSMIT BUFFER EMPTY
RPAR	EQU	00001000B	; RECEIVE PARITY ERROR
ROV	EQU	00010000B	; RECEIVE OVERRUN ERROR
RFR	EQU	00100000B	; RECEIVE FRAMING ERROR
SYND	EQU	01000000B	; SYNC DETECTED
DSR	EQU	10000000B	; DATA SET READY INPUT
;
; TTY TAPE READER CONSTANTS
;
RADCT	EQU	40		; TTY TAPE READER ADVANCE TIMER COUNT
RTOCT	EQU	250		; TTY TAPE READER TIMEOUT COUNT
TADV	EQU	TXEN OR RXEN OR RTS OR DTR
COMD	EQU	TXEN OR RXEN OR RTS
;
; TTY I/O PORTS
;
TTYI	EQU	0F4H		; TTY INPUT DATA PORT
TTYO	EQU	0F4H		; TTY OUTPUT DATA PORT
TTYS	EQU	0F5H		; TTY INPUT STATUS PORT
TTYC	EQU	0F5H		; TTY OUTPUT CONTROL PORT
;
; USER I/O PORTS
;
USCI	EQU	0F6H		; USER INPUT DATA PORT
USCS	EQU	0F7H		; USER INPUT STATUS PORT
USCO	EQU	0F6H		; USER OUTPUT DATA PORT
USCC	EQU	0F7H		; USER OUTPUT CONTROL PORT
;
; INTERVAL TIMER CONSTANTS
;
CTR0S	EQU	00000000B	; COUNTER 0 SELECT
CTR1S	EQU	01000000B	; COUNTER 1 SELECT
CTR2S	EQU	10000000B	; COUNTER 2 SELECT
LCTR	EQU	00000000B	; LATCHING COUNTER
RLMB	EQU	00100000B	; READ/LOAD MSB ONLY
RLLB	EQU	00010000B	; READ/LOAD LSB ONLY
RLLM	EQU	00110000B	; READ/LOAD LSB,MSB
MODE0	EQU	00000000B	; MODE 0
MODE1	EQU	00000010B	; MODE 1
MODE2	EQU	00000100B	; MODE 2
MODE3	EQU	00000110B	; MODE 3
MODE4	EQU	00001000B	; MODE 4
MODE5	EQU	00001010B	; MODE 5
BCDC	EQU	00000001B	; BCD COUNTER
B9600	EQU	7		; 9600 BAUD RATE FACTOR
B2400	EQU	32		; 2400 BAUD RATE FACTOR
B0110	EQU	698		;  110 BAUD RATE FACTOR
;
; INTERVAL TIMER (8253) I/O PORTS
;
CTR0P	EQU	0F0H		; LOAD COUNTER 0 OUTPUT COMMAND PORT
CTR1P	EQU	0F1H		; LOAD COUNTER 1 OUTPUT COMMAND PORT
CTR2P	EQU	0F2H		; LOAD COUNTER 2 OUTPUT COMMAND PORT
ITCP	EQU	0F3H		; INTERVAL TIMER OUTPUT COMMAND PORT
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; I/O CONTROLLER SYSTEM CONSTANTS
;
; I/O CONTROLLER PORTS
;
IOCI	EQU	0C0H		; I/O CONTROLLER INPUT DATA (FROM DBB) PORT
IOCO	EQU	0C0H		; I/O CONTROLLER OUTPUT DATA (TO DBB) PORT
IOCS	EQU	0C1H		; I/O CONTROLLER INPUT DBB STATUS PORT
IOCC	EQU	0C1H		; I/O CONTROLLER OUTPUT CONTROL COMMAND PORT
;
; CRT, KEYBOARD, AND FLOPPY DISK COMMANDS
;
CRTC	EQU	10H		; CRT OUTPUT DATA COMMAND
CRTS	EQU	11H		; CRT DEVICE STATUS COMMAND
KEYC	EQU	12H		; KEYBOARD INPUT DATA COMMAND
KSTS	EQU	13H		; KEYBOARD DEVICE STATUS COMMAND
KINT	EQU	14H		; RESERVED
WPBC	EQU	15H		; FLOPPY PARAMETER BLOCK TRANSFER COMMAND
WPBCC	EQU	16H		; FLOPPY PARAMETER BLOCK(CONT) TRANSFER COMMAND
WDBC	EQU	17H		; FLOPPY DATA BLOCK OUTPUT COMMAND
WDBCC	EQU	18H		; RESERVED
RDBC	EQU	19H		; FLOPPY INPUT DATA BLOCK COMMAND
RDBCC	EQU	1AH		; RESERVED
RRSTS	EQU	1BH		; FLOPPY RESULT STATUS COMMAND
RDSTS	EQU	1CH		; FLOPPY DEVICE STATUS COMMAND
;
; CRT, KEYBOARD, AND FLOPPY STATUS BITS
;
KRDY	EQU	00000001B	; KEYBOARD READY WITH DATA
FRDY	EQU	00000001B	; FLOPPY READY FOR DATA
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; PARALLEL I/O SYSTEM CONSTANTS
;
; PARALLEL I/O PORTS
;
PIOI	EQU	0F8H		; PARALLEL I/O INPUT DATA (FROM DBB) PORT
PIOO	EQU	0F8H		; PARALLEL I/O OUTPUT DATA (TO DBB) PORT
PIOS	EQU	0F9H		; PARALLEL I/O INPUT DBB STATUS PORT
PIOC	EQU	0F9H		; PARALLEL I/O OUTPUT CONTROL COMMAND PORT
;
; PTR, PTP, LPT AND UPP COMMANDS
;
RDRC	EQU	010H		; READER DATA TRANSFER COMMAND
PTRREV	EQU	01100000B	; READER REVERSE DIRECTION 1 FRAME OPTION
PTRADV	EQU	01000000B	; READER ADVANCE DIRECTION 1 FRAME OPTION
RSTC	EQU	011H		; READER DEVICE STATUS COMMAND
PUNC	EQU	012H		; PUNCH DATA TRANSFER COMMAND
PSTC	EQU	013H		; PUNCH DEVICE STATUS COMMAND
LPTC	EQU	014H		; LINE PRINTER DATA TRANSFER COMMAND
LSTC	EQU	015H		; LINE PRINTER STATUS COMMAND
WPPC	EQU	016H		; WRITE TO UPP COMMAND
RPPC	EQU	017H		; READ FROM UPP COMMAND
RPSTC	EQU	018H		; READ UPP STATUS COMMAND
;
; LPT, PTR AND PTP STATUS BITS
;
LPTRY	EQU	00000001B	; LPT READY
PTRDY	EQU	00000001B	; PTR READY WITH DATA
PTPRY	EQU	00000001B	; PTP READY FOR DATA
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; PARALLEL I/O AND I/O CONTROLLER SYSTEM COMMANDS
;
PACIFY	EQU	00H		; REINITIALIZE SYSTEM
ERESET	EQU	01H		; ERROR RESET
SYSTAT	EQU	02H		; SYSTEM STATUS
DSTAT	EQU	03H		; DEVICE STATUS
SRQDAK	EQU	04H		; DEVICE SERVICE REQUEST ACK
SRQACK	EQU	05H		; SYSTEM SERVICE REQUEST ACK
SRQ	EQU	06H		; SERVICE REQUEST
;
; PARALLEL I/O AND I/O CONTROLLER DIAGNOSTIC COMMANDS
;
DECHO	EQU	07H		; DATA ECHO TEST
CSMEM	EQU	08H		; CHECKSUM MEMORY
TRAM	EQU	09H		; TEST RAM
SINT	EQU	0AH		; SYSTEM INTERRUPT CONTROL
;
;
; PARALLEL I/O AND I/O CONTROLLER STATUS CONSTANTS
;
OBF	EQU	00000001B	; SLAVE OUTPUT BUFFER IS FULL
IBF	EQU	00000010B	; SLAVE INPUT BUFFER IS FULL
F0	EQU	00000100B	; FLAG 0 - SLAVE IS BUSY, MASTER IS LOCKED OUT
CNOTD	EQU	00001000B	; DBB CONTAINS CONTROL INFO NOT DATA
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; FDCC (FLOPPY DISKETTE CHANNEL COMMAND) CONSTANTS
;
DPCPL	EQU	4		; DISK COMPLETION STATUS
LOWW	EQU	79H		; LOW(IOPB)
HI	EQU	7AH		; HIGH(IOPB)
RSTS	EQU	7BH		; DISK RESULT STATUS INPUT PORT
DSTS	EQU	78H		; DISK STATUS INPUT PORT
TRK0	EQU	3000H		; FIRST ADDRESS OF DISK BOOTSTRAP
;
;	CONDITIONAL ASSEMBLY SWITCHES
;
FALSE	EQU	0
TRUE	EQU	NOT FALSE
HMSK	EQU	0FFH		; SAFE MOVE OF 16 BITS INTO 8 BIT REGISTER
;
; GLOBAL CONSTANTS
;
ONEMS	EQU	112		; 1 MILLISECOND TIME CONSTANT
TOUT	EQU	250		; 250 MS. COUNTER FOR READER TIMEOUT
CR	EQU	0DH		; ASCII VALUE OF CARRIAGE RETURN
LF	EQU	0AH		; ASCII VALUE OF LINE FEED
ETX	EQU	03H		; MONITOR BREAK CHARACTER (CONTROL C)
;
; MONITOR I/O STATUS BYTE MASKS AND VALUES
;
CMSK	EQU	11111100B	; MASK FOR LOCAL CONSOLE I/O
RMSK	EQU	11110011B	; MASK FOR READER INPUT
PMSK	EQU	11001111B	; MASK FOR PUNCH OUTPUT
LMSK	EQU	00111111B	; MASK FOR LIST OUTPUT
;-----
CTTY	EQU	00000000B	; LOCAL CONSOLE = TTY
CCRT	EQU	00000001B	; LOCAL CONSOLE = CRT
BATCH	EQU	00000010B	; BATCH MODE:
				; CONSOLE INPUT = READER, CONSOLE OUTPUT = LIST
CUSE	EQU	00000011B	; USER DEFINED LOCAL CONSOLE I/O
;-----
RTTY	EQU	00000000B	; READER = TTY
RPTR	EQU	00000100B	; READER = PTR
RUSE1	EQU	00001000B	; USER DEFINED READER (1)
RUSE2	EQU	00001100B	; USER DEFINED READER (2)
;-----
PTTY	EQU	00000000B	; PUNCH = TTY
PPTP	EQU	00010000B	; PUNCH = PTP
PUSE1	EQU	00100000B	; USER DEFINED PUNCH (1)
PUSE2	EQU	00110000B	; USER DEFINED PUNCH (2)
;-----
LTTY	EQU	00000000B	; LIST = TTY
LCRT	EQU	01000000B	; LIST = CRT
LLPT	EQU	10000000B	; LIST = LPT
LUSE	EQU	11000000B	; USER DEFINED LIST
;
; LOCAL I/O SUBSYSTEM INTERRUPT PORTS
;
IICP0	EQU	0FBH		; INITIALIZATION COMMAND PORT 0
IICP1	EQU	0FAH		; INITIALIZATION COMMAND PORT 1
IOCP0	EQU	0FBH		; OPERATION COMMAND PORT 0
IOCP1	EQU	0FAH		; OPERATION COMMAND PORT 1
;
; LOCAL INTERRUPT STATUS AND CONTROL BITS
;
ITTYO	EQU	00000001B	; TTY OUTPUT INTERRUPT
ITTYI	EQU	00000010B	; TTY INPUT INTERRUPT
IPTP	EQU	00000100B	; PTP OUTPUT INTERRUPT
IPTR	EQU	00001000B	; PTR INPUT INTERRUPT
ICRTO	EQU	00010000B	; CRT OUTPUT INTERRUPT
ICRTI	EQU	00100000B	; CRT INPUT INTERRUPT
ILPT	EQU	01000000B	; LPT OUTPUT INTERRUPT
MENB	EQU	10000000B	; ENABLE MONITOR INTERRUPTS EXCEPT LEVEL 7
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; BOOTSTRAP CONSTANTS
;
FSTOP	EQU	0E7H		; FULL SYSTEM TOP OF MEMORY ADDRESS
FSTP	EQU	0F7H		; FULL SYSTEM TOP PAGE ADDRESS
FDOC	EQU	004H		; FLOPPY DISK OPERATION COMPLETE
ACHRM	EQU	07FH		; ASCII CHARACTER MASK
ITIMO	EQU	0FFH		; IOC TIMEOUT CONSTANT
LBMK	EQU	0FFH		; LOWER BYTE MASK
ICFG	EQU	041H		; CONSOLE CONFIGURATION STATUS
ICNP	EQU	001H		; INTEGRATED CONSOLE NOT PRESENT STATUS
LSTE	EQU	040H		; LIST DEVICE VALUE FOR CONSOLE
RTCC	EQU	1229		; REAL TIME CLOCK 1MS CONSTANT
DPRNT	EQU	08H		; DISK READY MASK
TRKL	EQU	26*128		; TRACK LENGTH
PARML	EQU	4		; PARAMETER LENGTH - 1
COP	EQU	0F809H		; ENTRY POINT FOR CONSOLE OUT
IOCDP1	EQU	0F821H		; ENTRY POINT FOR IOC DRIVER 1
IOCDP2	EQU	0F844H		; ENTRY POINT FOR IOC DRIVER 2
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; PAGE 0 DEDICATED RAM LOCATIONS, INITIALIZED BY BOOTSTRAP PROM CODE.
;
	ORG	0
RESET:
	DS	3		; TRAP TO MONITOR RESTART
IOBYT:
	DS	1		; I/O SYSTEM STATUS BYTE
MEMTOP:
	DS	2		; TOP OF RAM, ONLY H SAVED
INITIO:
	DS	1		; INITIAL I/O CONFIGURATION
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; BOOTSTRAP PROM CODE
;
BBASE	SET	0E800H
	ORG	BBASE
	JMP	BS0		; BRANCH AROUND DATE CODE BYTE
INIT:
	DB	0		; INITIALLY
				; CONSOLE = TTY,
				; READER = TTY,
				; PUNCH = TTY,
				; LIST = TTY
	DW	DATE		; DATE STAMP FOR BOOTSTRAP PROM
;
; FUNCTIONS:
;
;	A.	INITIALIZE INTERRUPT SYSTEM AND REAL TIME CLOCK
;		0. INITIALIZE PORT 0FFH (CPUC)
;		1. PROGRAM SYSTEM INTERRUPTS (8259)
;		2. MASK ALL SYSTEM INTERRUPTS BUT TRAP LOGIC
;		3. PROGRAM I/O SUBSYSTEM INTERRUPTS (8259)
;		4. MASK ALL I/O SUBSYSTEM INTERRUPTS
;		5. PROGRAM REAL TIME CLOCK
;
BS0:
	DI			; DISABLE INTERRUPT SYSTEM
	MVI	A,MOVBOT	; TURN ON RAM (ROM WILL NOW RESPOND ONLY TO ADDRESS E800H)
	OUT	CPUC
	MVI	A,BOVROF	; TURN OFF BUS OVERRIDE
	OUT	CPUC
	MVI	A,ENABL		; PSEUDO ENABLE OF INTERRUPTS
	OUT	CPUC
	MVI	A,ENAXP		; ENABLE AUXILIARY PROM
	OUT	CPUC
	MVI	A,ICW1		; OUTPUT INITIALIZATION COMMAND WORD 1
	OUT	SICP0		;	TO SYSTEM 8259
	OUT	IICP0		;	TO I/O 8259
	MVI	A,ICW2		; OUTPUT INITIALIZATION COMMAND WORD 2
	OUT	SICP1		;	TO SYSTEM 8259
	OUT	IICP1		;	TO I/O 8259
	MVI	A,NOT INT0	; INITIALIZE MASK REGISTER
	OUT	SOCP1		;	FOR SYSTEM 8259
	MVI	A,NOT INTA	; INITIALIZE MASK REGISTER
	OUT	IOCP1		;	FOR I/O 8259
	MVI	A,CTR2S OR MODE3 OR RLLM ; INITIALIZE 1MS REAL TIME CLOCK
	OUT	ITCP
	LXI	H,RTCC
	MOV	A,L
	OUT	CTR2P
	MOV	A,H
	OUT	CTR2P
;
;	B.	INITIALIZE RAM.
;		1. COMPUTE SIZE OF RAM MEMORY.
;		2. SET UP DEDICATED MEMORY LOCATIONS
;			USER I/O ENTRY POINTS (TOP OF MEMORY)
;			EXIT TEMPLATE
;			USER REGISTERS
;			USER INTERRUPT MASK
;			USER STACK
;			MONITOR STACK
;			RESTART ROUTINE JUMP ADDRESS
;
	LXI	H,0		; INITIAL VALUE H:=0, L:=0
BS1:
	INR	H		; INCREMENT BY 256 BYTE PAGES, I.E.100H,200H,...,F800H
	MOV	A,M		; FETCH CONTENTS OF MEMORY
	CMA			; INVERT IT
	MOV	M,A		; ATTEMPT TO WRITE IT BACK INTO MEMORY
	CMP	M		; IS LOCATION READ/WRITE, I.E. EXISTING RAM
	CMA			; INVERT AGAIN BACK TO ORIGINAL VALUE
	MOV	M,A		; WRITE ORIGINAL DATA VALUE BACK IN
	JZ	BS1		; YES, CONTINUE (I.E. STILL CONTIGUOUS RAM)
	DCX	H		; OTHERWISE, IT'S LAST ADDRESS IN RAM
	MVI	A,FSTOP		; LOAD FULL SYSTEM PAGE ADDRESS
	CMP	H		; TEST FOR FULL SYSTEM
	JNZ	BS2		; JUMP IF NOT FULL SYSTEM
	MVI	H,FSTP		; LOAD H WITH TOP PAGE ADDRESS
BS2:
	SHLD	MEMTOP		; STORE TOP OF MEMORY
	LXI	B,TOS		; MOVE EXIT TEMPLATE TO RAM
	MOV	L,C
	SPHL			; SET MONITOR'S STACK POINTER
BS3:
	LDAX	B
	MOV	M,A
	INR	C		; MOVE BOTH POINTERS
	INR	L
	JNZ	BS3		; END ON PAGE BOUNDARY
	MVI	L,SLOC AND HMSK	; SET UP INITIAL VALUE FOR USER STACK
	MOV	M,H    	   	; LOWER HALF OF STACK POINTER IS KNOWN
	DCR	M		; MERELY SET UPPER HALF
				; TRAP TO MONITOR (AT LOCATIONS 0,1,2)
	MVI	A,(JMP RESTART)
	STA	RESET
	LXI	H,RESTART	; SET UP RESTART 0 FOR BREAKPOINT
	SHLD	RESET+1		;    LOGIC
;
;	C.	PROGRAM I/O DEVICES.
;		1. BAUD RATE GENERATOR FOR CRT
;		2. USART FOR CRT
;		3. BAUD RATE GENERATOR FOR TTY
;		4. USART FOR TTY
;
	MVI	A,CTR1S OR MODE3 OR RLLM
	OUT	ITCP
	LXI	H,B2400		; CRT BAUD RATE
	MOV	A,L
	OUT	CTR1P
	MOV	A,H
	OUT	CTR1P
	MVI	A,ST2 OR R16X OR CL8
	OUT	USCC
	MVI	A,TXEN OR DTR OR RXEN OR RTS
	OUT	USCC
	MVI	A,CTR0S OR MODE3 OR RLLM
	OUT	ITCP
	LXI	H,B0110		; TTY BAUD RATE
	MOV	A,L
	OUT	CTR0P
	MOV	A,H
	OUT	CTR0P
	MVI	A,ST2 OR R16X OR CL8
	OUT	TTYC
	MVI	A,TXEN OR RXEN OR RTS
	OUT	TTYC
;
;	D.	DETERMINE IF INTEGRATED CONSOLE PRESENT
;
	MVI	L,ITIMO		; LOAD TIMEOUT CONSTANT
BS4:
	IN	IOCS		; INPUT DBB STATUS
	ANI	IBF OR OBF OR F0; MASK OFF STATUS FLAGS
		       	      	; AND TEST FOR SLAVE PRESENCE
	JZ	BS5		; JUMP IF INTEGRATED CONSOLE PRESENT
	CALL	BDLY		; DELAY 1 MS FOR ANY RESETS TO COMPLETE
	CALL	BDLY		; DELAY 1 MS.
	DCR	L		; DECREMENT TIMER
	JZ	BS8		; JUMP IF TIME EXPIRED
	JMP	BS4		; OTHERWISE TRY AGAIN
BS5:
	MVI	A,CRTS		; LOAD CRT DEVICE STATUS COMMAND
	OUT	IOCC		; OUTPUT COMMAND TO IOC CONTROL PORT
	MVI	L,ITIMO		; LOAD TIMEOUT CONSTANT
BS6:
	IN	IOCS		; INPUT DBB STATUS
	ANI	IBF OR OBF OR F0; MASK OFF STATUS FLAGS
	CPI	OBF		; TEST FOR SLAVE DONE; SOMETHING FOR THE MASTER
	JZ	BS7		; JUMP IF DONE
	CALL	BDLY		; DELAY 1 MS FOR ANY RESETS TO COMPLETE
	CALL	BDLY		; DELAY 1 MS.
	DCR	L		; DECREMENT TIMER
	JZ	BS8		; JUMP IF TIME EXPIRED
	JMP	BS6		; OTHERWISE, TRY AGAIN
BS7:
	IN	IOCI		; INPUT CRT DEVICE STATUS FROM DBB
	RRC			; TEST FOR CRT READY
	JC	BS9		; JUMP IF READY (INTEGRATED CRT PRESENT)
BS8:				; INTEGRATED CRT NOT PRESENT/READY SO RECORD THIS FACT
	LHLD	MEMTOP		; LOAD TOP OF MEMORY PAGE ADDRESS
	MVI	L,BLOC+1 AND LBMK ; LOAD CONFIGURATION ADDRESS
	MVI	A,ICNP		; LOAD INTEGRATED CONSOLE NOT PRESENT
	MOV	M,A		; STORE IN CONFIGURATION BYTE IN EXIT TEMPLATE
BS9:
;
;	E.	LOAD ISIS.T0 IF DISKETTE 0 IS READY
;
	XRA	A
	CMA			; A-REG = 0FFH
	PUSH	PSW		; THREE-VALUED FLAG:
				;    0FFH IF NEITHER FDCC NOR ISD SELECTED
				;    00H  IF FDCC SELECTED
				;    01H  IF ISD SELECTED
	IN	DSTS		; SAMPLE FDCC STATUS
				; STATUS = 00H IF NO CONTROLLER PRESENT
	ANI	00001000B	; IS FDCC CONTROLLER PRESENT?
	JZ	BS11		; JUMP TO ISD SECTION IF FDCC NOT PRESENT
	IN	DSTS		; SAMPLE FDCC STATUS AGAIN
	RRC			; DRIVE 0 READY STATUS ROTATED INTO CARRY BIT
	JNC	BSX1		; JUMP TO MONITOR IF FDCC CONTROLLER PRESENT
				;    AND DRIVE 0 NOT READY
				; THE FOLLOWING CODE IS USED TO WRITE THE DISK IOPB TO
				; PROCESSOR MEMORY SO THAT IF ICE IS BEING USED TO DEBUG
				; THE BOOT/MONITOR, THE DISK CONTROLLER CAN ACCESS THE IOPB
	LXI	H,1000H		; LOAD POINTER TO DESTINATION MEMORY
	LXI	D,IOPB		; LOAD POINTER TO SOURCE MEMORY FOR IOPB
	MVI	B,7		; LOAD IOPB LENGTH COUNT
MLP:
	LDAX	D		; LOAD BYTE OF IOPB
	MOV	M,A		; MOVE TO MEMORY
	INX	H		; INCREMENT IOPB POINTER
	INX	D		; INCREMENT MEMORY POINTER
	DCR	B		; DECREMENT IOPB LENGTH COUNT
	JNZ	MLP		; CONTINUE UNTIL ALL OF IOPB MOVED
	LXI	H,1000H		; RELOAD POINTER TO IOPB
	MOV	A,L		; A CONTAINS LSB OF IOPB ADDRESS
	OUT	LOWW		; LOW(IOPB)
	MOV	A,H		; A CONTAINS MSB OF IOPB ADDRESS
	OUT	HI		; HIGH(IOPB), START DISK I/O
BS10:
	IN	DSTS		; WAIT FOR FDCC TO COMPLETE
	ANI	OPCPL		; TEST FOR DISK COMPLETION
	JZ	BS10
	POP	PSW		; GET READY TO SET FLAG TO NEW VALUE
	XRA	A		; SET A TO ZERO TO INDICATE DRIVE OTHER THAN INTEGRATED
				; FLOPPY WAS ACCESSED CORRECTLY
	PUSH	PSW		; SAVE ON STACK
	JMP	BSX1		; BYPASS INTEGRATED FLOPPY BOOT
;
; LOAD ISIS.T0 FROM INTEGRATED DISK IF AVAILABLE
;
BS11:
	LHLD	MEMTOP		; LOAD TOP OF MEMORY PAGE ADDRESS
	MVI	L,BLOC+1 AND LBMK ; LOAD CONFIGURATION ADDRESS
	MOV	A,M
	RRC			; TEST FOR INTEGRATED CONSOLE PRESENT
	JC	BSX1		; JUMP IF IOC NOT PRESENT OR FUNCTIONAL
	MVI	B,RDSTS		; LOAD FLOPPY DEVICE STATUS COMMAND
	CALL	IOCDP1		; READ STATUS FROM I/O CONTROLLER
	ANI	DPRNT		; TEST FOR DRIVE PRESENT
	JZ	BSX1		; JUMP IF NOT PRESENT
	MVI	B,RDSTS		; LOAD FLOPPY DEVICE STATUS COMMAND
	CALL	IOCDP1		; READ STATUS FROM I/O CONTROLLER
				; SECOND STATUS READ USED TO INSURE DRIVE READY
	RRC			; TEST FOR DRIVE READY
	JNC	BSX1		; JUMP IF DRIVE NOT READY
	POP	PSW		; UNLOAD STACK
	XRA	A		; SET A TO 1 TO INDICATE
	INR	A		; INTEGRATED FLOPPY WAS ACCESSED
	PUSH	PSW		; SAVE ON STACK
	LXI	H,IOPB		; LOAD POINTER TO IOPB
	MVI	B,WPBC		; LOAD WRITE IOPB COMMAND
	MOV	C,M		; LOAD FIRST BYTE OF IOPB
	CALL	IOCDP2		; SEND BYTE TO IOC
	MVI	E,PARML		; LOAD IOPB LENGTH REMAINING
	MVI	B,WPBCC		; LOAD WRITE IOPB CONTINUE COMMAND
BS12:
	INX	H		; MOVE POINTER TO NEXT BYTE OF IOPB
	MOV	C,M		; MOVE TO C
	CALL	IOCDP2		; SEND TO IOC
	DCR	E		; DECREMENT IOPB LENGTH
	JNZ	BS12		; CONTINUE UNTIL ALL DATA TRANSMITTED
	MVI	B,RDSTS		; LOAD DEVICE STATUS COMMAND
BS13:
	CALL	IOCDP1		; READ STATUS FROM IOC
	ANI	OPCPL		; TEST FOR OPERATION COMPLETE
	JZ	BS13		; LOOP UNTIL DONE
	MVI	B,RRSTS		; LOAD RESULT STATUS COMMAND
	CALL	IOCDP1		; READ RESULT STATUS FROM IOC
	STA	TRK0-2		; SAVE FOR TEST LATER
	ORA	A		; SET CONDITION CODES
	JNZ	BSX1		; JUMP IF DISK OPERATION UNSUCCESSFUL
	LXI	H,TRK0		; LOAD POINTER TO DISK DESTINATION ADDRESS
	LXI	D,TRKL		; LOAD TRACK LENGTH
	MVI	B,RDBC		; LOAD DISK READ DATA COMMAND
	CALL	IOCDP1		; LOAD DATA FROM IOC
	MOV	M,A		; MOVE TO MEMORY
	DCX	D		; DECREMENT LENGTH
	INX	H		; MOVE POINTER TO NEXT LOCATION
BS14:
	IN	IOCS		; INPUT DBB STATUS
	ANI	IBF OR OBF OR F0; MASK OFF STATUS FLAGS
	CPI	OBF		; TEST FOR DATA IN BUFFER
	JNZ	BS14		; JUMP IF NO DATA
	IN	IOCI		; INPUT DATA FROM DBB
	MOV	M,A		; MOVE TO MEMORY
	INX	H		; MOVE POINTER TO NEXT LOCATION
	DCX	D		; DECREMENT LENGTH
	MOV	A,D		; LOAD D FOLLOWED BY E
	ORA	E		;
	JNZ	BS14		; CONTINUE UNTIL DONE
;
;	F.	DETERMINE COLD START LOCAL CONSOLE.
;
;-------------------------------
; CONSOLE IS EITHER INTEGRATED CRT, SERIAL CRT, OR TTY
BSX1:
	LHLD	MEMTOP		; LOAD TOP OF MEMORY PAGE ADDRESS
	MVI	L,BLOC+1 AND LBMK ; LOADCONFIGURATION ADDRESS
	MOV	A,M		; LOAD INTEGRATED CONSOLE FLAG
	RRC			; TEST FOR INTEGRATED CONSOLE PRESENT
	JC	BSX2		; JUMP IF INTEGRATED CONSOLE NOT PRESENT
	MVI	B,KSTS		; LOAD KEYBOARD STATUS COMMAND
	CALL	IOCDP1		; READ STATUS FROM IOC
	RRC			; TEST FOR KEYBOARD PRESENT
	RRC
	MVI	D,ICFG		; LOAD INITIAL CONFIGURATION
	JC	BSX5		; JUMP IF KEYBOARD PRESENT
;-----------------------------------
; CONSOLE IS EITHER SERIAL CRT OR TTY
BSX2:
	XRA	A		; ZERO A
	MOV	D,A		; D CONTAINS 0H, I.E.C=T,R=T,P=T,L=T
	IN	TTYS		; GET TTY STATUS
	ANI	RRDY		; IS IT READY?
	JZ	BSX3		; JUMP IF TTY NOT READY
	IN	TTYI		; OTHERWISE GET CHARACTER FROM TTY
	JMP	BSX4
BSX3:
	MVI	D,ICFG		; LOAD INITIAL CONFIGURATION STATUS
	IN	USCS		; GET SERIAL CRT STATUS
	ANI	RRDY		; IS IT READY/
	JZ	BSX2		; JUMP BACKWARDS IF CRT NOT READY
	IN	USCI		; OTHERWISE,  GET CHARACTER FROM CRT
BSX4:
	ANI	7FH		; MASK OUT PARITY BIT
	CPI	' '		; DID USER TYPE IN A SPACE CHARACTER?
	JNZ	BSX2		; START ALL OVER IF NOT A SPACE CHARACTER
;-------------------------------
; AT THIS POINT THE CONSOLE DEVICE HAS BEEN DETERMINED
BSX5:
	LXI	H,IOBYT		; HL POINTS TO I/O STATUS BYTE
	MOV	M,D		; REPLACE MODIFIED I/O STATUS BYTE
	MVI	L,INITIO	; HL POINTS TO INITIAL I/O STATUS BYTE
	MOV	M,D		; SET INITIAL I/O STATUS BYTE
;
;	G.	CALL THE DIAGNOSTIC PROGRAM
;
	CALL	DIAGBT
;
;	H.	IF DISK IS READY, TRANSFER TO ISIS.T0
;
	POP	PSW		; UNLOAD FLAG
	ORA	A		; SET CONDITION CODES
	JNZ	BSX6		; JUMP IF INTEGRATED CONSOLE ACCESSED
	IN	RSTS		; SAMPLE FDCC RESULT STATUS
	ORA	A		; SET CONDITION CODES
	JNZ	BSX10		; JUMP IF ERROR CONDITION
	IN	DSTS		; SAMPLE FDCC STATUS
	RRC			; IS IT READY?
	JNC	BSX9		; JUMP TO MONITOR IF DISK NOT READY
				; OTHERWISE, PRIOR TO TRANSFERRING CONTROL
				;    TO T0.BOOT, WRITE AN INSTRUCTION TO
				;    TURN OFF BOOTSTRAP PROM
	JMP	BSX8
BSX6:
	RLC			; TEST FOR NON DISK ACCESS
	JC	BSX9		; JUMP IF NO ACCESS
	LDA	TRK0-2		; LOAD TEMPORARY STORAGE FOR RESULT BYTE
	ORA	A		; SET CONDITION CODES
	JNZ	BSX10		; JUMP IF ERROR CONDITION
	MVI	B,RDSTS		; LOAD FLOPPY DEVICE STATUS COMMAND
	CALL	IOCDP1		; READ STATUS FROM I/O CONTROLLER
	RRC			; TEST FOR DRIVE READY
	JNC	BSX9		; JUMP IF NOT READY
BSX8:
	MVI	A,(OUT CPUC)	; LOAD OUTPUT INSTRUCTION
	STA	TRK0-2 		; STOR IN RAM BEFORE DISK BOOT
	MVI	A,CPUC		; LOAD PORT ADDRESS
	STA	TRK0-1
	MVI	A,BTDGOF	; TURN OFF BOOTSTRAP/DIAGNOSTIC ROM
	JMP	TRK0-2		; EFFECT IS SAME AS: MVI   A,BTDGOF
				;                    OUT   CPUC
				;		     JMP   TRK0
;
;	I.	OTHERWISE, TYPE SIGN-ON FOR RAM MONITOR
;
BSX9:
	LXI	H,VERS		; HL POINTS TO ADDRESS OF SIGN-ON MESSAGE
	MVI	B,LVER		; B CONTAINS LENGTH OF MESSAGE
	CALL	PRTM		; PRINT SIGN-ON MESSAGE
;
;	J.	BOOTSTRAP ALL DONE, SO BRANCH TO MONITOR.
;
	JMP	BEGIN		; AT THIS POINT, INTERRUPTS ARE DISABLED
;
;	K.	PRINT DISK ERROR MESSAGE
;
BSX10:
	LXI	H,ERMSG		; HL POINTS TO ADDRESS OF DISK ERROR MESSAGE
	MVI	B,LERM		; B CONTAINS LENGTH OF MESSAGE
	CALL	PRTM		; PRINT SIGN-ON MESSAGE
	JMP	BSX9		; PRINT MESSAGE
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
;	BDLY - BOOTSTRAP DELAY 1 MS SUBROUTINE
;
BDLY:
	MVI	C,ONEMS		; LOAD 1 MS. CONSTANT
BDLY1:
	DCR	C		; DECREMENT COUNTER
	JNZ	BDLY1		; JUMP IF NOT EXPIRED
	RET
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
;	PRTM - PRT SUBROUTINE FOR SIGN-ON MESSAGES
;
PRTM:
	MOV	C,M		; C CONTAINS A CHARACTER FROM THE MESSAGE
	CALL	COP		; PRINT ON CONSOLE
	INX	H
	DCR	B
	JNZ	PRTM		; KEEP LOOPING UNTIL ENTIRE MESSAGE IS OUTPUT
	RET
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
;	DISK I/O PARAMETER BLOCK
;
IOPB:
	DB	80H		; IOCW, NO UPDATE BIT SET
	DB	04H		; I/O INSTRUCTION, READ DISK 0
	DB	26		; READ 26 SECTORS
	DB	0		; TRACK 0
	DB	1		; SECTOR 1
	DW	TRK0		; LOAD ADDRESS
;
;	MONITOR SIGN-ON MESSAGE
;
VERS:	DB	CR,LF,'SERIES II MONITOR, V'
	DB	VER/10+'0','.',VER MOD 10+'0'
	DB	CR,LF
LVER	EQU	$-VERS		; LENGTH OF SIGN-ON MESSAGE
;
;	MONITOR ERROR SIGN-ON MESSAGE
;
ERMSG:	DB	CR,LF,'DISK ERROR',CR,LF
LERM	EQU	$-ERMSG		; LENGTH OF ERROR SIGN-ON MESSAGE
BTCKSM:	DB	0A6H		; BOOT CHKSUMS TO 55H
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; EXIT CODE TEMPLATE, TO BE EXECUTED IN RAM
; THIS CODE IS ORIGINATED SO AS TO BE ALIGNED
; AGAINST THE TOP OF A PAGE (1 PAGE = 256 BYTES)
;
	ORG	BBASE + 02C8H
TOS:				; BASE OF MONITOR WORK STACK
USER	EQU	TOS - 8		; BASE OF DEFAULT USER WORK STACK
ELOC:	DB	0EEH  		; E REGISTER STORAGE
DLOC:	DB	0DDH		; D REGISTER
CLOC:	DB	0CCH		; C REGISTER
BLOC:	DB	0BBH		; B REGISTER
	DB	0		; CONFIGURATION BYTE
				; BIT 0 = 0 IF INTEGRATED CRT IS PRESENT
				;       = 1 IF INTEGRATED CRT NOT PRESENT
ILOC:	DB	NOT INT0	; INTERRUPT MASK
FLOC:	DB	0FFH		; CPU FLAGS
ALOC:	DB	0AAH		; A REGISTER
	DB	USER AND HMSK	; LOW(SP)
SLOC:	DB	0    	 	; HIGH(SP)
;
EXIT:				; MONITOR STACK ORIGIN
	DI			; DISABLE INTERRUPTS TO PROTECT THIS SEQUENCE
	POP	D		; RESTORE D,E
	POP	B		; RESTORE B,C
	POP	PSW
	OUT	SOCP1
	POP	PSW		; RESTORE A AND FLAGS
	POP	H		; RESTORE ORIGINAL STACK VALUE
	SPHL
	LXI	H,1234H		; RESTORE H,L; 1234H IS FILLER WHICH WILL BE
				;    OVERWRITTEN BY RESTART ROUTINE
LLOC	EQU	$-2
HLOC	EQU	$-1
	EI			; ENABLE INTERRUPTS
	JMP	6789H		; RETURN TO INTERRUPTED CODE; 6789H IS FILLER
				;    WHICH WILL BE OVERWRITTEN BY 'G' COMMAND
				;    AND RESTART ROUTINE
PLOC	EQU	$-1
TLOC:	DW	0		; TRAP 1 ADDRESS
	DB	0		; TRAP 1 VALUE
	DW	0		; TRAP 2 ADDRESS
	DB	0		; TRAP 2 VALUE
XTBL:				; EXTENSIBLE I/O ENTRY POINTS
				;    FILLED IN WHEN USER GIVES ADDRESS OF OWN
				;    DRIVER ROUTINE VIA IODEF SYSTEM CALL IN MONITOR
CILOC:
	JMP	0
COLOC:
	JMP	0
R1LOC:
	JMP	0
R2LOC:
	JMP	0
P1LOC:
	JMP	0
P2LOC:
	JMP	0
L1LOC:
	JMP	0
CSLOC:
	JMP	0
ENDX:				; THIS LABEL SHOULD BE AT 0EA00H.
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; SELECTION CODES FOR USER I/O ENTRY POINTS
;
UCI	EQU	(CILOC-XTBL)/3
UCO	EQU	(COLOC-XTBL)/3
UR1	EQU	(R1LOC-XTBL)/3
UR2	EQU	(R2LOC-XTBL)/3
UP1	EQU	(P1LOC-XTBL)/3
UP2	EQU	(P2LOC-XTBL)/3
UL1	EQU	(L1LOC-XTBL)/3
UCS	EQU	(CSLOC-XTBL)/3
; END OF BOOTSTRAP PROM CODE
;*******************************************************************************
DIAGMN	EQU	0EB00H		; STARTING ADDRESS OF DIAGNOSTIC PROGRAM
				;    WHEN ENTERED FROM CALL FROM MONITOR
DIAGBT	EQU	0EB03H		; STARTING ADDRESS OF DIAGNOSTIC PROGRAM
				;    WHEN ENTERED FROM CALL FROM BOOT
	ORG	0EB00H		; WHEN BURNING THE PROM, THIS SECTION OF CODE
				;    WILL BE OVERLAYED BY THE REAL DIAGNOSTIC
				;    PROGRAM.
	RET
	NOP
	NOP
	RET			; 0EB03H
				;    BOOTSTRAP/DIAGNOSTIC PROM
;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
;***                                                                         ***
;***            START OF MONITOR PROPER                                      ***
;***                                                                         ***
;*******************************************************************************
;*******************************************************************************
;*******************************************************************************
BASE	EQU	0F800H		; BASE ADDRESS OF MONITOR
	ORG	BASE		; TOP 2K OF 64K ADDRESS SPACE
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; BRANCH TABLE FOR I/O SYSTEM (EXTERNAL I/O ENTRY POINTS)
;
; THE MONITOR IS ENTERED AT ENTRY POINT 'BEGIN' VIA A JUMP FROM THE BOOTSTRAP;
; THIS IN TURN LEADS TO A JUMP TO ENTRY POINT 'START'.  THE OTHER ENTRIES
; IN THIS "TABLE" ARE EXTERNAL I/O ENTRY POINTS KNOWN TO THE USER PLUS
; THE DATE, VERSION, AND COPYRIGHT STAMPS.
BEGIN:
	JMP	START0		; RESET ENTRY POINT
	JMP	CI		; LOCAL CONSOLE INPUT
	JMP	RI		; READER INPUT
	JMP	CO		; LOCAL CONSOLE OUTPUT
	JMP	PO		; PUNCH OUTPUT
	JMP	LO		; LIST OUTPUT
	JMP	CSTS		; LOCAL CONSOLE INPUT STATUS
	JMP	IOCHK		; I/O SYSTEM STATUS
	JMP	IOSET		; SET I/O CONFIGURATION
	JMP	MEMCHK		; COMPUTE SIZE OF MEMORY
	JMP	IODEF		; DEFINE USER I/O ENTRY POINTS
	JMP	IOCDR1		; IOC INPUT
	DW	DATE		; DATE STAMP FOR MONITOR ROM
	JMP	UI		; UPP INPUT
	JMP	UO		; UPP OUTPUT
	JMP	UPPS		; UPP STATUS
	DB	VERH		; VERSION STAMP FOR MONITOR ROM
	DB	'(C)INTEL CORP1978'	; COPYRIGHT NOTICE IN ASCII REP
	JMP	IOCCOM		; IOCCOM ENTRY POINT
	JMP	IOCDR2		; IOC OUTPUT
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'ERROR' - ENTERED VIA JUMP FROM VARIOUS ROUTINES WHEN AN ERROR IS DETECTED
; PROCESS: ABNORMAL EXIT FOR ALL MONITOR ERROR CONDITIONS. BECAUSE OF THE
;          UNKNOWN STATE OF THE MONITOR AS A RESULT OF A COMMAND OR DATA ERROR,
;          THE VALUE OF THE MONITOR STACK POINTER IS REINITIALIZED AND
;          EXECUTION CONTINUES TO THE MAIN COMMAND LOOP.
; INPUT: MEMTOP,TOS
; OUTPUT: SP POINTS TO BASE OF MONITOR STACK IN TOP PAGE OF CONTIGUOUS RAM
; MODIFIED: H,L, SP
; STACK USAGE:
;
; REGISTER USAGE
; X = MODIFIED BY THIS ROUTINE, CONTENTS UNDEFINED.
; S = SET BY THIS ROUTINE, RETURNED AS A RESULT.
; U = USED AS INPUT.
;       A -
;       B -             C - S
;       D -             E -
;       H - X           L - X
;       CARRY - X       ZERO - X
;       SIGN - X        PARITY - X
;       SP - S          PC -
;       STACK USAGE: 2 BYTES
ERROR:
	LHLD	MEMTOP		; H POINTS TO TOP PAGE OF MEMORY
	MVI	L,TOS AND 0FFH	; L POINTS TO BASE OF STACK WITHIN THAT PAGE
	SPHL	      	  	; SP NOW POINTS TO BASE OF MONITOR STACK
	CALL	COMC		; OUTPUT THE ERROR INDICATOR CHAR '#'
	DB	'#'
				; FALL THROUGH TO MAIN COMMAND LOOP
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; MAIN COMMAND LOOP.
;
; THIS LOOP IS THE STARTING POINT OF ALL COMMAND SEQUENCES.
; IT IS ENTERED VIA A JUMP FROM THE BEGINNING OF THE MONITOR PROPER CODE,
; A FALL THROUGH FROM THE ERROR ROUTINE, OR A RETURN FROM A MONITOR COMMAND
; ROUTINE.
; IN THIS CODE INTERRUPTS ARE ENABLED AND A CARRIAGE RETURN
; AND LINE FEED ARE TYPED ALONG WITH THE PROMPT CHARACTER, '.'.
; WHEN A CHARACTER IS ENTERED FROM THE LOCAL CONSOLE KEYBOARD, IT
; IS CHECKED FOR VALIDITY, THEN A BRANCH TO THE PROPER
START0:
	MVI	A,BTDGOF	; DISABLE BOOT, I.E. SWITCH BOOT PROM
	OUT	CPUC		;    OUT OF ADDRESSABLE MEMORY SPACE
START:
	EI			; ENABLE INTERRUPTS
	CALL	CRLF		; TYPE <CR>,<LF>
	CALL	COMC		; OUTPUT A PERIOD
	DB	'.'
	CALL	TI		; GET A CHARACTER, ECHO IT.
	CPI	CR		; IS IT A CARRIAGE RETURN?
	JZ	START		; JUMP IF IT IS
	SUI	'A'		; OTHERWISE TEST FOR A-Z (VALID COMMAND RANGE)
	JM	ERROR		; LESS THAN A, NOT A VALID COMMAND
	MVI	C,2		; ASSUME THE COMMAND NEEDS 2 PARAMETERS
	LXI	D,START		; SET UP PSEUDO RETURN ADDRESS TO SIMULATE
	PUSH	D		;    EFFECT OF A CALL. COMMANDS WHICH PERFORM
				;    A RETURN WILL CAUSE THE STACK TO BE
				;    POPPED, THUS RETURNING TO ENTRY POINT
				;    START.  THE 'G' COMMAND, HOWEVER, WIPES
				;    OUT THIS ADDRESS WITH ANOTHER ADDRESS
				;    OF ITS OWN CHOOSING (I.E. USER'S PC).
	LXI	H,CTBL		; LOAD POINTER TO PROCESSING ROUTINE PTRS
	CPI	LCT		; TEST FOR OVERRUN
	JP	ERROR		; IF SO, THEN ERROR
	MOV	E,A		; OTHERWISE, MOVE INDEX TO DE
	MVI	D,0
	DAD	D
	DAD	D		; HL := CTBLBASE + (2 * INDEX); HL NOW POINTS
				;    TO PROPER COMMAND IN COMMAND BRANCH TABLE
	MOV	A,M		; GET LSB OF BRANCH LOCATION
	INX	H
	MOV	H,M		; GET MSB OF BRANCH LOCATION
	MOV	L,A		; HL POINTS TO ADDRESS OF COMMAND CODE
	PCHL			; TAKE THE BRANCH
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; COMMAND BRANCH TABLE.
;
; THIS TABLE CONTAINS THE ADDRESSES OF THE ENTRY POINTS OF
; ALL THE COMMAND PROCESSING ROUTINES.  IT IS ENTERED FROM THE MAIN
; COMMAND LOOP.  NOTE THAT AN ENTRY TO 'ERROR'
; IS AN ERROR CONDITION, I.E., NO COMMAND CORRESPONDING TO THAT
; CHARACTER EXISTS.
CTBL:
	DW	ASSIGN		; A - ASSIGN I/O UNITS
	DW	ERROR		; B -
	DW	ERROR		; C -
	DW	DISP		; D - DISPLAY RAM MEMORY
	DW	EOF		; E - ENDFILE A HEXADECIMAL FILE
	DW	FILL		; F - FILL MEMORY
	DW	GOTO		; G - GO TO MEMORY ADDRESS
	DW	HEXN		; H - HEXADECIMAL SUM AND DIFFERENCE
	DW	ERROR		; I -
	DW	ERROR		; J -
	DW	ERROR		; K -
	DW	ERROR		; L -
	DW	MOVE		; M - MOVE MEMORY
	DW	NULL		; N - PUNCH NULLS FOR LEADER ON PAPER TAPE
	DW	ERROR		; O -
	DW	ERROR		; P -
	DW	QUERY		; Q - QUERY I/O SYSTEM STATUS
	DW	READ		; R - READ HEXADECIMAL PAPER TAPE FILE
	DW	SUBS		; S - SUBSTITUTE MEMORY
	DW	ERROR		; T -
	DW	ERROR		; U -
	DW	ERROR		; V -
	DW	WRITE		; W - WRITE FILE TO PAPER TAPE IN HEX FORMAT
	DW	X		; X - EXAMINE AND MODIFY REGISTERS
	DW	ERROR		; Y -
	DW	Z		; Z - INVOKE THE DIAGNOSTIC PROGRAM
LCT	EQU	($-CTBL)/2	; LCT = NUMBER OF 16-BIT ENTRIES IN TABLE
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'A' COMMAND - ASSIGN I/O DEVICE
;
; THIS ROUTINE MAPS SYMBOLIC DEVICE IDENTIFIERS TO BITS
; IN THE I/O STATUS BYTE (IOBYT) TO ALLOW FOR LOCAL CONSOLE
; MODIFICATIONS OF SYSTEM I/O CONFIGURATION.
ASSIGN:
	CALL	TI		; GET LOGICAL DEVICE CHARACTER (C,R,P,L)
	LXI	H,LTBL		; ADDRESS OF MASTER TABLE
	MVI	C,4		; MAXIMUM OF 4 ENTRIES
;	--------------------------------------------------------------------
AS0:				; HL POINTS TO IDENTIFYING CHARACTER IN LTBL
	CMP	M		; DOES A-REG CONTAIN C,R,P, OR L?
	INX	H		; HL POINTS TO CORRESPONDING DEVICE MASK
	JZ	AS1		; YES IT DOES
	INX	H
	INX	H
	INX	H		; HL POINTS TO NEXT 4-BYTE ENTRY IN LTBL
	DCR	C		; DECREMENT LOOP COUNT
	JNZ	AS0		; TRY NEXT ENTRY
	JMP	ERROR		; NO MATCH, ERROR
;	--------------------------------------------------------------------------
AS1:				; USER HAS SPECIFIED A VALID LOGICAL DEVICE
	MOV	B,M		; B := LOGICAL DEVICE MASK
	INX	H		; HL CONTAINS SUBORDINATE PHYS.DEV.TBL.ADDRESS
	MOV	E,M		; E CONTAINS LSB OF PDT ADDRESS
	INX	H
	MOV	D,M		; D CONTAINS MSB OF PDT ADDRESS
	XCHG			; HL POINTS TO I/O SYSTEM PHYSICAL DEVICE
				;    TABLE (I.E. ACT,ART,APT, OR ALT)
;	------------------------------------------------------------------------
ALUP1:				; SCAN INPUT UNTIL '='
	CALL	TI
	CPI	'='
	JNZ	ALUP1
;	-------------------------------------------------------------------------
ALUP2:				; SCAN INPUT WHILE ' ' (BLANK)
	CALL	TI
	CPI	' '
	JZ	ALUP2
;	------------------------------------------------------------------------
	MVI	C,4		; SET TABLE LENGTH
AS2:				; INDEX THROUGH PHYSICAL UNIT TABLE
	CMP	M		; COMPARE DEVICE CHAR WITH LEGAL VALUES
	INX	H		; HL CONTAINS DEVICE SELECT BIT PATTERN
	JZ	AS3		; USER HAS SPECIFIED A VALID PHYS.DEVICE ASSIGNMNT
	INX	H		; HL POINTS TO NEXT ENTRY WITHIN THE TABLE
	DCR	C
	JNZ	AS2		; CONTINUE LOOKUP
	JMP	ERROR		; ERROR RETURN
;	-----------------------------------------------------------------
AS3:
ALUP3:				; SCAN INPUT UNTIL <CR>
	CALL	TI
	CPI	CR
	JNZ	ALUP3
	LDA	IOBYT		; GET I/O STATUS
	ANA	B		; B CONTAINS LOG DEV MASK.  CLEAR OUT THE
				;    APPROPRIATE FIELD IN IOBYT BECAUSE WE ARE
				;    GOING TO CHANGE IT.
	ORA	M		; PUT IN THE NEW STATUS FIELD
	STA	IOBYT		; RETURN IT TO MEMORY
	RET			; RETURN CONTROL TO MAIN COMMAND LOOP
;
; MASTER I/O DEVICE TABLE
; 4 BYTES/ENTRY
;
;    BYTE 0 = IDENTIFYING CHARACTER
;    BYTE 1 = LOGICAL DEVICE MASK
;    BYTES 2,3 = ADDRESS OF SUBORDINATE PHYSICAL DEVICE TABLE
;
LTBL:
	DB	'C',CMSK
	DW	ACT
	DB	'R',RMSK
	DW	ART
	DB	'P',PMSK
	DW	APT
	DB	'L',LMSK
	DW	ALT
;
; I/O SYSTEM PHYSICAL DEVICE TABLES
; 2 BYTES/ENTRY
;
;   BYTE 0 = IDENTIFYING CHARACTER
;   BYTE 1 = DEVICE SELECT BIT PATTERN
;
ACT:
	DB	'T',CTTY	; LOCAL CONSOLE = TTY
	DB	'C',CCRT	; LOCAL CONSOLE = CRT
	DB	'B',BATCH	; BATCH MODE LOCAL CONSOLE = READ,LIST
	DB	'1',CUSE	; USER DEFINED LOCAL CONSOLE DEVICE
ART:
	DB	'T',RTTY	; READER = TTY
	DB	'P',RPTR	; READER = PTR
	DB	'1',RUSE1	; USER DEFINED READER DEVICE 1
	DB	'2',RUSE2	; USER DEFINED READER DEVICE 2
APT:
	DB	'T',PTTY	; PUNCH = TTY
	DB	'P',PPTP	; PUNCH = PTP
	DB	'1',PUSE1	; USER DEFINED PUNCH DEVICE 1
	DB	'2',PUSE2	; USER DEFINED PUNCH DEVICE 2
ALT:
	DB	'T',LTTY	; LIST = TTY
	DB	'C',LCRT	; LIST = CRT
	DB	'L',LLPT	; LIST = LPT
	DB	'1',LUSE	; USER DEFINED LIST DEVICE
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'D' COMMAND - DISPLAY CONTENTS OF MEMORY ON LIST DEVICE
;
; THIS ROUTINE EXPECTS TWO HEXADECIMAL PARAMETERS SPECIFYING
; THE BOUNDS OF A MEMORY AREA TO BE DISPLAYED ON THE
; LIST DEVICE.  THE MEMORY AREA IS DISPLAYED 16 BYTES
; PER LINE, WITH THE MEMORY ADDRESS OF THE FIRST BYTE
; PRINTED FOR REFERENCE.  ALL LINES ARE BLOCKED INTO INTEGRAL
; MULTIPLES OF 16 FOR CLARITY, SO THE FIRST AND LAST LINES MAY
; BE LESS THAN 16 BYTES IN ORDER TO SYNCHRONIZE THE DISPLAY.
DISP:
	CALL	EXPR		; GET TWO ADDRESSES
	POP	D		; GET HIGH ADDRESS
	POP	H		; GET LOW ADDRESS
DIO:
	CALL	LCRLF		; PRINT CR,LF
	CALL	DADR		; PRINT MEMORY ADDRESS
DI1:
	MVI	C,' '
	CALL	LOM		; PRINT SPACE
	MOV	A,M
	CALL	DBYTE		; PRINT DATA
	CALL	HILO		; TEST FOR COMPLETION
	JC	DI2		; RETURN TO MAIN LOOP
	MOV	A,L
	ANI	0FH		; PRINT CR,LF,ADDRESS ON MULTIPLE OF 16
	JNZ	DI1
	JMP	DI0
DI2:
	CALL	LCRLF		; WRITE CR,LF
	MVI	C,0
	CALL	LOM		; WRITE A NULL TO TRIGGER CLOSE
	RET
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'E' COMMAND - PUNCH HEXADECIMAL END-OF-FILE
;
; THIS ROUTINE PRODUCES A TERMINATION RECORD WHICH PROPERLY
; COMPLETES A HEXADECIMAL FILE CREATED BY 'W' COMMANDS.
; IT EXPECTS ONE HEXADECIMAL PARAMETER, WHICH IT INTERPRETS AS THE
; START ADDRESS TO BE LOADED INTO THE USER'S PROGRAM COUNTER (LOCATED
; IN EXIT TEMPLATE) ON A SUBSEQUENT 'R' COMMAND; THIS START ADDRESS
; WILL REPLACE THE STORED VALUE OF THE USER'S PROGRAM COUNTER ONLY
; IF THE START ADDRESS IS NONZERO.
;
EOF:
	DCR	C		; C:=1; GET ONE PARAMETER
	CALL	EXPR		; PUT <START ADDRESS> ON TOP OF STACK
	CALL	POC		; OUTPUT RECORD MARK (':')
	DB	':'
	XRA	A		; ZERO CHECKSUM
	MOV	D,A		; D := 0; A := 0
	CALL	PBYTE		; OUTPUT A RECORD LENGTH OF ZERO
	POP	H		; RETRIEVE START ADDRESS
	CALL	PADR		; OUTPUT IT AS THE LOAD ADDRESS
	MVI	A,1		; RECORD TYPE = 1
	CALL	PBYTE		; OUTPUT RECORD TYPE
	XRA	A		; A := 0
	SUB	D		; D CONTAINS RUNNING CHECKSUM
	CALL	PBYTE		; OUTPUT CHECKSUM := -D
	JMP	NUO		; PUNCH TRAILER AND RETURN
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'F' COMMAND - FILL RAM WITH 8-BIT CONSTANT
;
; THIS ROUTINE EXPECTS THREE HEXADECIMAL PARAMETERS, THE
; FIRST AND SECOND (16 BITS) ARE INTERPRETED AS THE BOUNDS
; OF A MEMORY AREA TO BE INITIALIZED TO A CONSTANT VALUE,
; THE THIRD PARAMETER (8 BITS) IS THAT VALUE.
FILL:
	INR	C		; C:=3; GET 3 PARAMETERS
	CALL	EXPR
	POP	B		; C := 8-BIT CONSTANT
	POP	D		; DE := HIGH ADDRESS
	POP	H		; HL := LOW ADDRESS
FI0:
	MOV	M,C		; STORE CONSTANT IN MEMORY
	CALL	HILO		; TEST FOR COMPLETION
	JNC	FI0		; CONTINUE LOOPING
	RET			; GO BACK TO START
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'G' COMMAND - GO TO <ADDRESS>, OPTIONALLY SET BREAKPOINT(S)
;
; THE G COMMAND IS USED FOR TRANSFERRING CONTROL FROM THE
; MONITOR TO A USER PROGRAM.  IT HAS SEVERAL MODES OF
; OPERATION.
; IF ONE HEXADECIMAL PARAMETER IS ENTERED, IT IS INTERPRETED
; AS THE ENTRY POINT OF THE USER PROGRAM AND A TRANSFER TO
; THAT LOCATION IS EXECUTED.
; IF ADDITIONAL (UP TO 2) PARAMETERS ARE ENTERED, THESE ARE
; CONSIDERED 'BREAKPOINTS', I.E., LOCATIONS WHERE
; CONTROL IS TO BE RETURNED TO THE MONITOR WHEN THEY ARE
; ENCOUNTERED IN COURSE OF EXECUTING THE USER PROGRAM.
; IF THE FIRST PARAMETER IS NOT ENTERED, THE STORED VALUE
; OF THE USER'S PROGRAM COUNTER (REGISTER P) IS USED AS
; THE USER PROGRAM ENTRY POINT.
;
; THIS COMMAND WORKS IN THE FOLLOWING MANNER:
;  1. IT FINDS THE EXIT CODE IN TOP OF RAM AND PLACES THIS ADDRESS IN THE
;     MONITOR'S STACK, REPLACING THE RETURN ADDRESS TO ENTRY POINT START
;     THAT WAS PLACED THERE BY THE MAIN COMMAND LOOP.
;  2. IF THERE IS NO FURTHER INPUT (I.E. ONLY <CR>) THEN BY EXECUTING A
;     RET, WE CAUSE EXECUTION OF THE EXIT CODE, WHICH CONTAINS A JUMP TO
;     A) A DUMMY ADDRESS (IF IMPROPER USE OF COMMAND), B) THE PROGRAM
;     COUNTER FROM WHEN THE USER PROGRAM WAS INTERRUPTED OR BREAKPOINT
;     WAS ENCOUNTERED.
;  3. IF THERE IS A START ADDRESS SPECIFIED, THIS VALUE IS STORED OVER
;     THAT PART OF THE EXIT CODE WHICH CONTAINS THE JMP INSTRUCTION.
;     IF THERE IS NO FURTHER INPUT, A RET IS EXECUTED AND THE EXIT
;     CODE IS EXECUTED.
;  4. IF TRAPS (BREAKPOINTS) ARE TO BE SET, THEN THEY ARE READ IN AND PLACED
;     ON THE MONITOR STACK.  THEY ARE THEN STORED IN THE PROPER SECTION OF
;     THE EXIT TEMPLATE. ALSO, IN THE USER'S PROGRAM THE INSTRUCTION SPECIFIED
;     BY THE BREAKPOINT ADDRESS IS SAVED IN THE EXIT TEMPLATE AND REPLACED
;     WITH A RST 0 INSTRUCTION.
;  5. THE EXIT CODE IS EXECUTED AND CONTROL IS PASSED TO THE USER PROGRAM.
GOTO:
	LHLD	MEMTOP
	MVI	L,EXIT AND 0FFH	; HL NOW POINTS TO EXIT CODE IN TOP OF RAM
	XTHL	       	   	; REPLACE THE START RETURN ADDRESS IN THE
				;    STACK (PUSHED BY MAIN COMMAND LOOP) WITH
				;    THIS EXIT CODE ADDRESS SO THAT WHEN THE
				;    G COMMAND DOES A RETURN, THE EXIT CODE
				;    WILL BE EXECUTED INSTEAD OF THE MAIN
				;    COMMAND LOOP.
	CALL	PCHK		; GET A CHARACTER, SET Z,C
	JZ	GO0		; IF ' ', ',' OR <CR>: JUMP, DON'T CHANGE PC
	CALL	PA0		; GET NEW PC VALUE
	XCHG			; DE = NEW PC
	LHLD	MEMTOP
	MVI	L,PLOC AND 0FFH	; HL NOW POINTS TO PLOC IN EXIT CODE IN TOP OF RAM
	MOV	M,D    	   	; STORE MSB OF MODIFIED PC IN EXIT CODE IN RAM
	DCX	H
	MOV	M,E		; STORE LSB OF MODIFIED PC IN EXIT CODE IN RAM
GO0:
	JC	GO4		; JUMP IF <CR> (NO TRAPS TO BE SET)
	LXI	D,2		; SET COUNTER(S), D=0, E=2
GO1:
	CALL	COMC		; ISSUE A PROMPT FOR A TRAP
	DB	'-'
	CALL	PARAM		; GET A TRAP
	PUSH	H		; STACK IT
	INR	D		; UP 1 COUNTER
	JC	GO2		; TERMINATE IF CR ENTERED
	DCR	E		; DOWN THE OTHER
	JNZ	GO1		; GET ONE MORE TRAP
GO2:				; D CONTAINS HOW MANY TRAPS (1 OR 2)
	JNC	ERROR		; LAST TRAP NOT FOLLOWED BY CR
	LHLD	MEMTOP
	MVI	L,TLOC AND 0FFH	; HL NOW POINTS TO TLOC (BEGINNING OF TRAP
		       	   	;    AREA) IN EXIT TEMPLATE IN TOP OF RAM
GO3:				; BC CONTAINS THE USER SPECIFIED TRAP ADDRESS
	POP	B		; GET A TRAP (BREAKPOINT) ADDRESS
	MOV	M,C		; STORE LSB OF TRAP ADDRESS INTO TRAP AREA
	INX	H
	MOV	M,B		; STORE MSB OF TRAP ADDRESS INTO TRAP AREA
	INX	H
	LDAX	B		; FETCH OPCODE BYTE
	MOV	M,A		; PUT IN TRAP AREA
	INX	H
	MVI	A,(RST 0)	; REPLACE THE USER'S OPCODE IN USER PROGRAM
	STAX	B      		;    WITH A RST 0
	DCR	D
	JNZ	GO3		; DO SAME THING AGAIN FOR 2ND BREAKPOINT
GO4:
	CALL	CRLF
	RET			; EXECUTE MONITOR EXIT CODE, RETURNING TO
				;    USER CODE
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
; 'H' COMMAND - COMPUTE HEXADECIMAL SUM AND DIFFERENCE
;
; THIS ROUTINE EXPECTS TWO HEXADECIMAL PARAMETERS.
; IT COMPUTES THE SUM AND DIFFERENCE OF THE TWO VALUES
; AND DISPLAYS THEM ON THE LOCAL CONSOLE DEVICE AS FOLLOWS:
; <P1+P2> <P1-P2>
HEXN:
	CALL	EXPR		; GET TWO NUMBERS
	CALL	CRLF
	POP	D		; DE CONTAINS P2
	POP	H
	PUSH	H		; HL CONTAINS P1
	DAD	D		; HL := HL + DE := P1 + P2
	CALL	LADR		; DISPLAY SUM
	CALL	BLK		; TYPE A SPACE
	POP	H		; HL CONTAINS P1 AGAIN
	MOV	A,L		; COMPUTE HL-DE
	SUB	E		; A := LSB OF P1 - LSB OF P2
	MOV	L,A		; A := LSB OF (P1 - P2)
	MOV	A,H
	SBB	D		; A := MSB OF P1 - MSB OF P2 WITH CARRY
	MOV	H,A		; H := MSB OF (P1 -P2)
	CALL	LADR		; DISPLAY DIFFERENCE
	RET
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'M' COMMAND - MOVE A BLOCK OF MEMORY
;
; THIS ROUTINE EXPECTS THREE HEXADECIMAL PARAMETERS FROM THE
; LOCAL CONSOLE. THE FIRST AND SECOND PARAMETERS ARE THE BOUNDS OF
; THE MEMORY AREA TO BE MOVED, THE THIRD PARAMETER IS THE
; STARTING ADDRESS OF THE DESTINATION AREA.
MOVE:
	INR	C		; GET THREE ADDRESSES
	CALL	EXPR
	POP	B		; DESTINATION ADDRESS
	POP	D		; SOURCE END ADDRESS
	POP	H		; SOURCE START ADDRESS
MV0:
	MOV	A,M		; GET A DATA BYTE
	STAX	B		; STORE AT DESTINATION
	INX	B		; MOVE DESTINATION POINTER
	CALL	HILO		; TEST FOR COMPLETION
	JNC	MV0
	RET
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'N' COMMAND - PUNCH NULL CHARACTERS FOR TAPE LEADER/TRAILER
;
; THIS ROUTINE PUNCHES 60 NULL CHARACTERS ON THE DEVICE ASSIGNED
; AS THE PUNCH.  IT IS ENTERED VIA A JUMP TO ENTRY POINT NU0
; FROM THE 'E' COMMAND AS WELL AS BEING INVOKED BY
; THE 'N' COMMAND.
NULL:
	CALL	TI		; REQUIRE CR
	CPI	CR
	JNZ	ERROR
NU0:
	MVI	B,60		; SET TO PUNCH 60 NULLS
NLEADX:
	CALL	POC		; PUNCH ONE ASCII NULL CHARACTER (=00H)
	DB	0
	DCR	B
	JNZ	NLEADX		; DO IT FOR 60 TIMES
	RET
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'Q' COMMAND - I/O SYSTEM STATUS QUERY
;
; THIS COMMAND IS INVOKED BY TYPING THE LETTER Q.  THIS
; COMMAND PRODUCES A LISTING OF LOGICAL I/O DEVICES AND
; THEIR CORRESPONDING PHYSICAL DEVICE ASSIGNMENTS.  THE
; DATA DISPLAYED IS EQUIVALENT TO THE CURRENT VALUE OF IOBYT.
QUERY:
	CALL	TI		; REQUIRE CR
	CPI	CR
	JNZ	ERROR
	MVI	B,4		; SET UP OUTER LOOP COUNTER.
				;    THERE ARE 4 LOGICAL DEVICES.
	LXI	H,LTBL		; POINT HL AT LOGICAL DEVICE TABLE.
Q0:				; OUTER LOOP
	CALL	CRLF		; START A NEW LINE.
	MOV	C,M		; DISPLAY LOGICAL DEVICE IDENTIFIER.
	CALL	COM
	CALL	COMC		; DISPLAY '='
	DB	'='
	INX	H		; POINT AT MASK FOR LOGICAL DEVICE.
	MOV	A,M		; FETCH MASK.
	CMA			; INVERT IT
	MOV	C,A		; PUT IN C
	INX	H		; POINT AT PHYSICAL DEVICE TABLE
	MOV	E,M		; ADDRESS OF SUBORDINATE
	INX	H		; TABLE
	MOV	D,M
	INX	H
	XCHG			; HL <- PHYSICAL DEVICE TABLE
	LDA	IOBYT
	ANA	C		; PHYSICAL SELECTION
	PUSH	B		; SAVE OUTER LOOP COUNTER
	MVI	B,4		; SET UP INNER LOOP COUNTER
Q1:				; INNER LOOP
	MOV	C,M		; GET PHYSICAL DEVICE IDENTIFIER
	INX	H
	CMP	M		; TEST FOR EQUALITY
	JZ	Q2
	INX	H		; POINT AT NEXT ENTRY
	DCR	B		; DECREMENT INNER LOOP
	JNZ	Q1
Q2:
	CALL	COM		; DISPLAY PHYSICAL DEVICE
	XCHG			; POINT AT MASTER TABLE
	POP	B
	DCR	B		; DECREMENT OUTER LOOP
	JNZ	Q0
	RET
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
;
; 'R' COMMAND - READ HEXADECIMAL FILE
;
; THIS ROUTINE READS A HEXADECIMAL FILE FROM THE ASSIGNED
; READER DEVICE AND LOADS IT INTO MEMORY.  ONE HEXADECIMAL
; PARAMETER IS EXPECTED.  THIS PARAMETER IS A BASE ADDRESS
; TO BE ADDED TO THE MEMORY ADDRESS OF EACH DATA BYTE ENCOUNTERED.
; IN THIS WAY, HEXADECIMAL FILES MAY BE LOADED INTO MEMORY
; IN AREAS OTHER THAN THAT FOR WHICH THEY WERE ASSEMBLED OR COMPILED.
; ALL RECORDS READ ARE CHECKSUMMED AND COMPARED AGAINST THE
; CHECKSUM IN THE RECORD. IF A CHECKSUM ERROR (OR TAPE READ ERROR)
; OCCURS, THE ROUTINE TAKES AN ERROR EXIT.  NORMAL LOADING IS
; TERMINATED WHEN AN EOF RECORD IS ENCOUNTERED. THE ADDRESS
; GIVEN WHEN THE EOF RECORD WAS CREATED (VIA THE 'E' COMMAND) REPLACES
; THE USER'S STORED PC VALUE ONLY IF THE ADDRESS WAS NONZERO.
; A TRANSFER TO THE PROGRAM MAY THEN BE ACCOMPLISHED BY A 'G<CR>'.
READ:
	DCR	C		; GET ONE ADDRESS; C := 1
	CALL	EXPR		; GET THE HEX BASE ADDRESS
	CALL	CRLF		; OUTPUT A <CR>,<LF>
RED0:
	CALL	RIX		; GET AN ASCII CHARACTER FROM THE READER
	CPI	':'		; IS IT A START OF RECORD MARK (':')?
	JNZ	RED0		; LOOP UNTIL WE FIND SUCH A RECORD MARK
	XRA	A
	MOV	D,A		; D WILL CONTAIN THE CHECKSUM; INITIALIZE TO 0
	CALL	BYTE		; READ 2 ASCII CHAR REPRESENTING THE RECORD
				;    LENGTH AND DECODE THEM INTO 8 BITS BINARY
				;    STORING THE RESULT IN A-REG
	JZ	RED3		; JUMP IF ZERO RECORD LENGTH BECAUSE THIS
				;    MEANS IT'S AN EOF RECORD SO WE'RE DONE
	MOV	E,A		; E := RECORD LENGTH
	CALL	BYTE		; GET MSB OF LOAD ADDRESS
	MOV	H,A		; H := MSB OF LOAD ADDRESS
	CALL	BYTE		; GET LSB OF LOAD ADDRESS
	MOV	L,A		; L := LSB OF LOAD ADDRESS
	CALL	BYTE		; GET RECORD TYPE AND IGNORE IT
	MOV	C,E		; C := RECORD LENGTH
	PUSH 	H		; STORE LOAD ADDRESS ON THE STACK
	LXI	H,-256		; COMPUTE BUFFER POINTER
	DAD	SP		; HL NOW POINTS TO THAT PART OF THE MONITOR
				;    STACK ONE PAGE (256 BYTES) BELOW WHERE
				;    THE SP IS CURRENTLY POINTING
				; WE WILL NOW READ DATA FROM THE FILE RECORD
				; AND STORE THEM TEMPORARILY IN THE MONITOR'S
				; STACK STARTING FROM A LOW MEMORY ADDRESS AND
				; MOVING TOWARD A HIGHER MEMORY ADDRESS (REVERSE
				; OF USUAL PROCEDURE WHERE STACK GROWS DOWN)
RED1:
	CALL	BYTE		; READ DATA; NOTE: 8 BITS OF MEMORY (DATA)
				;    IS REPRESENTED AS 2 HEX CHAR AND EACH HEX
				;    HEX CHAR IS REPRESENTED AS ONE 8 BIT ASCII CHAR
	MOV	M,A		; PUT DATA IN MONITOR BUFFER
	INX	H		; MOVE "UP" THE STACK
	DCR	E		; DECREMENT RECORD LENGTH COUNT
	JNZ	RED1		; LOOP UNTIL RECORD LENGTH COUNTER IS 0
	CALL	BYTE		; READ THE CHECKSUM RECORD FRAME --- PRIOR TO
				;    CALL TO BYTE, D-REG CONTAINED SUM OF DATA
				;    RECORDS. THE CHECKSUM FRAME SHOULD CONTAIN
				;    THE NEGATIVE OF THIS SUM. BYTE ADDS D AND A
				;    TOGETHER AND SETS THE ZERO BIT IF D = (-A)
	JNZ	ERROR		; CHECKSUM ERROR
	POP	D		; DE = LOAD ADDRESS; STACK ENTRY POINTED TO BY SP
				;    NOW CONTAINS BASE (BIAS) ADDRESS
	XTHL			; HL = BIAS ADDRESS; CONTENTS OF STACK ENTRY
				;    POINTED TO BY SP NOW IS ADDRESS ONE ABOVE
				;    WHERE LAST DATA IS STORED IN MONITOR STACK
	XCHG			; DE = BIAS ADDRESS, HL = LOAD ADDRESS
	DAD	D		; HL = BIAS + LA
	MVI	B,0		; BC = RECORD LENGTH (RL)
	DAD	B		; HL = BIAS + LA + Rl
	XCHG			; DE = BIAS + LA + RL, HL = BIAS
	XTHL			; HL POINTS TO ADDRESS 1 GREATER THAN WHERE LAST
				;    DATA IS STORED IN MONITOR STACK
;------------------------------
RED2:				; LOAD INTO PROPER AREA IN RAM BUT IN
				;    REVERSE ORDER
	DCX	H		; DECREMENT STACK BUFFER POINTER
	MOV	A,M		; A := DATA
	DCX	D		; DECREMENT MEMORY POINTER
	STAX	D		; PUT DATA IN DESIGNATED ADDRESS
	DCR	C		; KEEP DOING THIS UNTIL RECORD LENGTH
	JNZ	RED2		;    COUNT IS EXHAUSTED
	JMP	RED0		; DONE WITH ONE RECORD, GO GET ANOTHER
;-------------------------------
RED3:				; EOF RECORD - ENTIRE FILE HAS BEEN READ IN
	PUSH	B		; SAVE B,C
	CALL	BYTE		; GET MSB OF LOAD ADDRESS OF EOF RECORD ---
				;    THIS IS THE <START ADDRESS> SPECIFIED IN
				;    THE 'E' COMMAND. IF IT IS ZERO, DO NOT
				;    MODIFY THE USER'S STORED PC IN EXIT TEMPLATE
	MOV	B,A		; B := MSB OF START ADDRESS
	CALL	BYTE		; GET LSB OF START ADDRESS
	MOV	C,A		; C := LSB OF START ADDRESS
	ORA	B		; SEE IF START ADDRESS IS 0000
	JZ	RED4		; JUMP IF IT IS (DON'T SET NEW PC)
	LHLD	MEMTOP
	MVI	L,PLOC AND 0FFH	; HL POINTS TO PLOC IN EXIT CODE IN TOP OF RAM
	MOV	M,B    	   	; STORE MSB OF START ADDRESS
	DCX	H		; HL POINTS TO PLOC - 1 OF EXIT CODE
	MOV	M,C		; STORE LSB OF START ADDRESS
RED4:				; FINISH PROCESSING EOF RECORD
	POP	B		; RESTORE B,C
	CALL	BYTE		; GET RECORD TYPE AND IGNORE IT
	CALL	BYTE		; GET CHECKSUM
	JNZ	ERROR		; JUMP IF CHECKSUM ERROR
	POP	H		; CUT BACK STACK POINTER
	RET
;*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
